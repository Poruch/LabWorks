Program Main;
{Создание бинарного дерева, просмотр и вывод элементов на экран, удаление вершин}

    Type RefTree = ^Tree; {ссылка на узел дерева}
         Tree = record {структура вершины}
                      Inf: Integer; {информационное поле}
                      Left, Right: RefTree {ссылки на левое и правое поддеревья}
                end;
    var Root: RefTree; {ссылка на корень}
        C: integer; {переменная для ввода данных из файла}
        InputFile: Text; {файл исходных данных}
        FileName: string; {имя файла}

    Procedure InsNode(var R: RefTree; C: Integer);
    {Вставка вершины в бинарное дерево.                                        }
    {R - ссылка на корень дерева; C - значение для вставки (ключ).             }
    {Предполагается, что в дереве нет вершины с тем же значением ключевого поля}
       begin
           if R = nil then {Нашли "свободное место" - вставляем вершину:}
           begin new(R);
                 R^.Inf := C;
                 R^.Left := nil; R^.Right := nil {всегда добавляем лист}
           end
           else {Ищем место для размещения новой вершины 
                 в зависимости от введённого значения}
                if C < R^.Inf 
                then InsNode(R^.Left, C) {вставляемое значение меньше - вставляем в левое поддерево }
                else InsNode(R^.Right, C){вставляемое значение больше - вставляем в правое поддерево}
       end;

    Procedure BrTreeLR(R: RefTree);
    {Вывод значений, размещённых в дереве, в порядке возрастания значений }
    {R - ссылка на корень дерева                                          }
       begin
           if R <> nil then
           begin
                 BrTreeLR(R^.Left);
                 write(R^.Inf:5);
                 BrTreeLR(R^.Right)
           end
       end;

    Procedure BrTreeRL(R: RefTree);
    {Вывод значений, размещённых в дереве, в порядке убывания значений }
    {R - ссылка на корень дерева                                       }
       begin
           if R <> nil then
           begin
                 BrTreeRL(R^.Right);
                 write(R^.Inf:5);
                 BrTreeRL(R^.Left)
           end
       end;

    Procedure DelNode(var Root: RefTree; C: integer);
    {Удаление вершины дерева:                                                  }
    {R - ссылка на корень дерева; C - удаляемое значение.                      }    
    {Возможны 3 варианта:                                                      }
    { 1. Удаляется лист.                                                       }
    { 2. Удаляется узел, у которого есть один потомок.                         }
    { 3. Удаляется узел, у которого есть два потомка.                          }
    {Для 1 и 2 порядок удаления одинаковый (аналогично удалению из линейного списка: }
    {в вершине-предке удаляемой вершина дерева меняется ссылка на потомка - найденный}
    {для удаления узел исключается из дерева, ссылка на него запоминается - для осво-}
    {бождения памяти, занимаемой удаляемым узлом).                                   }
    {В случае 3 в найденный узел переносится значение из вершины-потомка (максимума  }
    {среди меньших или минимума среди больших) - это лист или вершина с 1 потомком,  }
    {затем этот потомок исключается из дерева вместо найденного узла с удаляемым     }
    {значением                                                                       }
    
       var Q: RefTree; {ссылка на найденную для удаления вершину}
       procedure Del(var R: RefTree);
       { Вспомогательная процедура поиска элемента для замены при удалении узла,}
       {у которого есть два потомка: для замены ищем максимальное значение среди}
       {меньших удаляемого "крайний правый слева от удаляемого".                }
       {Найденное значение заменяет удаляемое без нарушения порядка сортировки в}
       {дереве, а сама найденная вершина удаляется из дерева (это лист или узел,}
       {у которого есть только один потомок).                                   }
           begin
                if R^.Right <> nil then Del(R^.Right)
                else begin {нашли "крайнего правого потомка" удаляемой вершины}
                       Q^.Inf := R^.Inf; {замена удаляемого значения на найденное}
                       Q := R; {переносим ссылку - удаляем найденную вершину}
                       R := R^.Left {исключаем её из дерева - она будет удалена}
                     end
           end;
       begin
            if Root = nil then writeln('Такой вершины нет!')
            else {поиск вершины для удаления из дерева по её значению}
                 if C < Root^.Inf then {удаляем "слева" от текущей вершины}
                    DelNode(Root^.Left, C)
                 else if C > Root^.Inf then {удаляем "справа" от текущей вершины}
                         DelNode(Root^.Right,C)
                      else begin {нашли вершину по значению - будем удалять}
                              Q := Root; {запоминаем ссылку на удаляемую вершину}
                              if Q^.Right = nil {справа нет потомка}
                              then Root := Q^.Left {исключаем вершину из дерева}
                              else if Q^.Left = nil {слеваа нет потомка}
                                   then Root := Q^.Right {исключаем вершину из дерева}
                                   else Del(Q^.Left); {есть два потомка - ищем замену}
                              dispose(Q) {вершина исключена из дерева - освобождаем память}
                           end
       end;

begin
    Root := nil;
    write('Введите имя файла: > ');
    readln(FileName);
    assign(InputFile, FileName);
    reset(InputFile);
    writeln('Ввели данные из файла:');
    while not eof(InputFile) do
    begin readln(InputFile, C);
          write(C:5); 
          InsNode(Root, C)
    end;
    close(InputFile);
    writeln('');
    writeln('По возрастанию:');
    BrTreeLR(Root);
    writeln('');
    writeln('По убыванию:');
    BrTreeRL(Root);
    writeln('');
    repeat
          write('Введите значение для удаления или 0 для завершения:');
          readln(C);
          if C<>0 then DelNode(Root, C);
          writeln('');
          writeln('По возрастанию:');
          BrTreeLR(Root);
          writeln('');
          writeln('По убыванию:');
          BrTreeRL(Root);
          writeln('');
    until C=0
end.